<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>容器镜像系列教程:(一)初识Docker</title>
    <link href="/2025/03/02/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-(%E4%B8%80)%E5%88%9D%E8%AF%86Docker/"/>
    <url>/2025/03/02/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-(%E4%B8%80)%E5%88%9D%E8%AF%86Docker/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker技术简介"><a href="#Docker技术简介" class="headerlink" title="Docker技术简介"></a>Docker技术简介</h2><p>Docker，目前非常热门的一项技术，只要你从事软件开发，就一定听说过这项技术。那，Docker究竟是什么？让我们来看下维基百科对它下的定义：<strong>Docker 是一种工具，用于在轻量级容器中自动部署应用程序，以便应用程序可以在不同的环境中隔离高效工作</strong>。Docker容器技术在云计算时代是非常重要的技术底座，极大地提升了程序的部署和分发效率。</p><h2 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h2><p>为什么要使用Docker？在回答这个问题之前，我们需要先看一下在容器技术出现之前，大家是使用什么环境去部署应用程序的。</p><p>在Docker技术之前，大家基本上是使用虚拟机来进行应用部署的。比方说，我开发了一个qq这样的应用程序，我需要部署它的服务端，我需要将qq的软件包上传到虚拟机上，再对虚拟机上的环境变量或者配置文件进行编辑，最终，再使用启动脚本运行该程序，这就是一个常见的部署场景，但是，这中间有两个问题，第一个问题是<strong>多实例的扩容非常麻烦</strong>，假设需要在另一台服务器上再部署该程序，需要将虚拟机上的应用程序打包，同时还要在另一台服务器上安装各种各样的依赖，如果已经做成标准化的脚本还好，要是没有，那得麻烦死；第二个问题是<strong>虚拟机本身是重载的，消耗资源</strong>，运行虚拟机本身就是很耗费资源的一件事，同时，如果在一个虚拟机上跑多个应用程序，程序之间可能会存在互相影响，导致多个应用程序运行异常。</p><p>为了解决上面提到的两个问题，Docker技术应运而生，同时兼顾了轻量化、隔离性好和容易迁移的特性。</p><p>应用在容器中运行，容器运行在宿主机上，每个容器是单独的、互相隔离的环境。容器的应用部署架构图和虚拟机的应用架构部署图如下，区别在于虚拟机部署需要一套重载的OS系统，这消耗了大量不必要的资源。</p><p><img src="/img/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/%E5%AE%B9%E5%99%A8VS%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="img"></p><h2 id="Docker技术原理"><a href="#Docker技术原理" class="headerlink" title="Docker技术原理"></a>Docker技术原理</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>在Docker技术中，有以下三种核心概念：</p><ul><li><p>镜像（Image)：</p><p>镜像是容器的静态模板，包含运行应用程序所需的所有文件和配置。镜像由多层只读文件系统组成，每一层代表一个构建步骤（如安装软件、添加文件）。镜像通过<code>Dockerfile</code>定义，使用<code>docker build</code>命令构建。</p></li><li><p>容器（Container)：</p><p>容器是Docker的核心运行单元，是一个轻量级、独立、可执行的软件包，包含应用程序及其所有依赖项（如库、环境变量、配置文件）。容器基于镜像创建，运行在隔离的用户空间中，与宿主机共享操作系统内核，但拥有独立的文件系统、网络和进程空间。</p></li><li><p>仓库（Registry）：</p><p>仓库是用于存储和分发镜像的集中化平台，分为公共仓库（如Docker Hub）和私有仓库（如自建Harbor）。镜像通过<code>docker push</code>上传到仓库，通过<code>docker pull</code>下载。</p></li></ul><p>三者之间的关系可以用下图表示：</p><p><img src="/img/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/docker%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="img"></p><h3 id="底层技术原理"><a href="#底层技术原理" class="headerlink" title="底层技术原理"></a>底层技术原理</h3><p>相信听到docker的神奇效果，你也会想知道到底docker是如何实现这样神奇的功效的，下面来介绍一下Docker容器化技术所使用到的两大核心底层技术：命名空间（Namespace）和控制组（CGroup）。</p><hr><h4 id="1-命名空间（Namespace）"><a href="#1-命名空间（Namespace）" class="headerlink" title="1. 命名空间（Namespace）"></a>1. <strong>命名空间（Namespace）</strong></h4><p>命名空间是Linux内核提供的一种隔离机制，用于将系统资源（如进程、网络、文件系统等）划分为独立的虚拟空间，使得每个命名空间中的资源对其他命名空间不可见。容器通过命名空间实现资源隔离，确保每个容器拥有独立的运行环境。</p><p><strong>主要命名空间类型</strong>：</p><ul><li><strong>PID Namespace</strong>：隔离进程ID，容器内的进程从PID 1开始，与宿主机进程隔离。</li><li><strong>Mount Namespace</strong>：隔离文件系统挂载点，容器拥有独立的文件系统视图。</li><li><strong>Network Namespace</strong>：隔离网络接口、IP地址、路由表等，容器拥有独立的网络栈。</li><li><strong>UTS Namespace</strong>：隔离主机名和域名，容器可以拥有独立的主机名。</li><li><strong>IPC Namespace</strong>：隔离进程间通信（如消息队列、共享内存）。</li><li><strong>User Namespace</strong>：隔离用户和用户组ID，容器内的root用户不等于宿主机的root用户。</li></ul><p><strong>作用</strong>：</p><ul><li>提供资源隔离，确保容器之间互不干扰。</li><li>增强安全性，限制容器对宿主机和其他容器的影响。</li></ul><hr><h4 id="2-控制组（CGroup）"><a href="#2-控制组（CGroup）" class="headerlink" title="2. 控制组（CGroup）"></a>2. <strong>控制组（CGroup）</strong></h4><p>控制组是Linux内核提供的一种资源管理机制，用于限制、记录和隔离进程组的资源使用（如CPU、内存、磁盘I&#x2F;O等）。容器通过CGroup实现资源限制和优先级控制，确保容器不会过度占用宿主机资源。</p><p><strong>主要功能</strong>：</p><ul><li>资源限制：限制容器使用的CPU、内存、磁盘I&#x2F;O等资源。</li><li>优先级控制：为容器分配资源使用优先级。</li><li>资源统计：记录容器的资源使用情况，便于监控和优化。</li><li><strong>进程控制</strong>：冻结、恢复或终止容器内的进程。</li></ul><p><strong>作用</strong>：</p><ul><li>防止单个容器耗尽宿主机资源，影响其他容器或系统稳定性。</li><li>提供细粒度的资源管理，优化资源利用率。</li></ul><hr><h4 id="命名空间与CGroup的关系"><a href="#命名空间与CGroup的关系" class="headerlink" title="命名空间与CGroup的关系"></a><strong>命名空间与CGroup的关系</strong></h4><ul><li><strong>命名空间</strong>：负责资源隔离，确保容器拥有独立的运行环境。</li><li><strong>CGroup</strong>：负责资源限制，确保容器不会过度占用资源。<br>两者结合，共同实现容器的轻量级虚拟化和资源管理。</li></ul><h2 id="Docker实用工具和生态"><a href="#Docker实用工具和生态" class="headerlink" title="Docker实用工具和生态"></a>Docker实用工具和生态</h2><ol><li><p><strong>开发与部署工具</strong>  </p><ul><li><strong>Docker Compose</strong>：多容器编排的YAML定义（<code>docker-compose.yml</code>）。</li><li><strong>Docker Swarm</strong>：原生集群管理（与Kubernetes的定位差异）。</li><li><strong>Kubernetes集成</strong>：Docker作为容器运行时（CRI规范）。</li></ul></li><li><p><strong>镜像与安全工具</strong>  </p><ul><li><strong>Docker Slim</strong>：镜像瘦身优化。</li><li><strong>Trivy&#x2F;Clair</strong>：镜像漏洞扫描。</li><li><strong>Docker Bench for Security</strong>：安全基线检查。</li></ul></li><li><p><strong>监控与可视化</strong>  </p><ul><li><strong>cAdvisor</strong>：容器资源监控。</li><li><strong>Portainer</strong>：图形化管理界面。</li></ul></li><li><p><strong>CI&#x2F;CD场景实践</strong>  </p><ul><li><strong>GitLab CI与Docker</strong>：自动化构建与测试。</li><li><strong>Jenkins Pipeline</strong>：容器化构建环境配置。</li></ul></li></ol><hr><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h3><p>在当前的云计算领域，K8S已经成为编排部署的事实标准，而K8S正是使用容器化技术作为根基，随着越来越多的人使用容器化技术，容器化将继续为人们带来高效便捷的部署能力，并发展出新的功能特性，反过来推动云原生发展壮大。本文碍于篇幅，只对核心概念和原理等做了简要概述，该系列文章后续将更侧重于实际的使用，我们下一篇文章再见！</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p><a href="https://www.docker.com/">Docker: Accelerated Container Application Development</a></p><p><a href="https://zhuanlan.zhihu.com/p/126687430">Docker容器技术介绍（内含详细教程） - 知乎</a></p><p><a href="https://en.wikipedia.org/wiki/Docker_(software)">Docker (software) - Wikipedia</a></p>]]></content>
    
    
    <categories>
      
      <category>系列教程</category>
      
      <category>容器镜像系列教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容器</tag>
      
      <tag>Docker</tag>
      
      <tag>镜像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/05/hello-world/"/>
    <url>/2024/05/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java手写一个简单的HashMap</title>
    <link href="/2021/09/11/Java%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HashMap/"/>
    <url>/2021/09/11/Java%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HashMap/</url>
    
    <content type="html"><![CDATA[<h4 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h4><p>HashMap在Java中是常用的数据结构之一。HashMap 是一个散列表，它存储的内容是键值对(key-value)映射，并具有很快的访问速度。在JDK1.7中，HashMap是基于“数组+链表”实现的，而在JDK1.8以后，HashMap在底层实现中加入了红黑树用于提升查找速率。</p><p><img src="/img/hashmap.png"><br>    <center><font face="宋体" size=3 color="black">图源网络，侵删</font></center><br><br></p><p>在JDK1.8中，当链表的长度大于阈值8时，这时这个链表将会转化成红黑树以提升查找效率。为什么阈值是8呢？请读者不妨思考一下这个问题，在文章末尾笔者将给出原因。（提示：想一想在红黑树和链表中查找一个元素的复杂度）</p><p>好了，关于HashMap就简单介绍到这里，接下来我们关注于自己实现一个HashMap—MyHashMap。</p><h4 id="2-目标"><a href="#2-目标" class="headerlink" title="2.目标"></a>2.目标</h4><p>在本次实现中，我们的目标如下：</p><ul><li>实现put(k, v)，该方法返回V类型的元素，这里返回为空即可。</li><li>实现get(k)，该方法返回这个建对应的值v。</li><li>实现remove(k)，该方法将这个键对应的键值对删除，并返回对应的值v，如果不存在对应的键，返回空。</li><li>实现size()，该方法返回HashMap中的键值对数目。</li></ul><p>明确我们的目标后，就可以关注于具体实现了。</p><h4 id="3-手写HashMap"><a href="#3-手写HashMap" class="headerlink" title="3.手写HashMap"></a>3.手写HashMap</h4><h5 id="3-1定义MyMap接口"><a href="#3-1定义MyMap接口" class="headerlink" title="3.1定义MyMap接口"></a>3.1定义MyMap接口</h5><p>这个接口定义了我们需要实现的具体行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMap</span> &lt;K, V&gt;&#123;<br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(K k)</span>;<br><br>    V <span class="hljs-title function_">put</span><span class="hljs-params">(K k, V v)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br><br>    V <span class="hljs-title function_">remove</span><span class="hljs-params">(K k)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们要根据这个接口的定义完成我们的MyHashMap类去实现接口中定义的行为。</p><h5 id="3-2定义链表节点"><a href="#3-2定义链表节点" class="headerlink" title="3.2定义链表节点"></a>3.2定义链表节点</h5><p>因为HashMap中存在着链表，所以我们也需要实现一个链表。我们以内部类的形式定义这样一个节点Entry，Entry类保存了”K-V”数据，next字段表明它可能会是一个链表节点。</p><p>参考形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashMap</span> &lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-comment">//定义内部类Entry作为链表节点</span><br>     <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K, V&gt;&#123;<br>         K k;<br>         V v;<br>         Entry&lt;K,V&gt; next;<br><br>         <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(K k, V v)</span>&#123;<br>             <span class="hljs-built_in">this</span>.k = k;<br>             <span class="hljs-built_in">this</span>.v = v;<br>         &#125;<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="3-2定义成员变量"><a href="#3-2定义成员变量" class="headerlink" title="3.2定义成员变量"></a>3.2定义成员变量</h5><p>这里参照HashMap设置一个默认的容量capacity和默认的加载因子loadFactor，table就是底层数组，另外，考虑到size方法的实现，这里肯定还需要一个成员变量size用于表示HashMap的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义成员变量</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><span class="hljs-keyword">private</span> <span class="hljs-type">float</span> loadFactor;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>Entry&lt;K,V&gt;[] table;<br></code></pre></td></tr></table></figure><h5 id="3-3实现构造方法"><a href="#3-3实现构造方法" class="headerlink" title="3.3实现构造方法"></a>3.3实现构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyHashMap</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-built_in">this</span>(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">float</span> loadFactor)</span>&#123;<br>   <span class="hljs-built_in">this</span>.capacity = upperMinPowerOf2(capacity);     <span class="hljs-comment">//获取为2的幂次方的容量大小</span><br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;                  <span class="hljs-comment">//加载因子，用于扩容,本次实现中尚未用到该字段</span><br>    <span class="hljs-built_in">this</span>.table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[capacity];<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>upperMinPowerOf2</code>的作用是获取大于capacity的最小的2次幂。在HashMap中，开发者采用了更精妙的位运算的方式完成了这个功能，效率比这种方式要更高。capacity要求为2次幂是为了方便HashMap在数组扩容时能够更好地对已存在的元素进行重新哈希。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">upperMinPowerOf2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">power</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(power &lt;= n)&#123;<br>        power *= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> power;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-4实现put方法"><a href="#3-4实现put方法" class="headerlink" title="3.4实现put方法"></a>3.4实现put方法</h5><p>put方法将传入的键值对封装成一个Entry&lt;K, V&gt;对象进行存入，存入数组中的index我们通过对键哈希取模得到，这样能减少哈希冲突，也就能减少链表的数目，能提高HashMap的查找效率。</p><p>假如数组中没有元素，那么直接将该Entry放入对应位置即可。</p><p>假如数组中已经存在元素，我们需要遍历这个链表，检查是否存在有相等的key（这里用equals方法会更好），如果存在相等key，那么用新值替换旧值，然后返回；如果不存在，那么就使用头插法插入链表。</p><p>记得对size做正确的操作，保持记录的元素个数正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K k, V v)</span> &#123;<br>    <span class="hljs-comment">// 通过hashcode散列获取索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> k.hashCode() % table.length;<br>    Entry&lt;K,V&gt; current = table[index];<br>    <span class="hljs-comment">//判断是否已经存在元素</span><br>    <span class="hljs-keyword">if</span> (current!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">// 遍历链表是否有相等key, 有则替换且返回旧值</span><br>        <span class="hljs-keyword">while</span> (current!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(current.k == k)&#123;<br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> current.v;<br>                current.v = v;<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>            current = current.next;<br>        &#125;<br>        <span class="hljs-comment">// 没有则使用头插法</span><br>        table[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;K, V&gt;(k,v, table[index]);<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//不存在元素直接放入即可</span><br>    table[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;K, V&gt;(k,v,<span class="hljs-literal">null</span>);<br>    size++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-5实现get方法"><a href="#3-5实现get方法" class="headerlink" title="3.5实现get方法"></a>3.5实现get方法</h5><p>get方法通过键k获取对应的值v，根据put中存放的索引位置，get方法中也是一样的计算方法。</p><p>遍历链表，如果检查存在键为k的键值对Entry，那么就返回对应的值v，没有则返回空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K k)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> k.hashCode() % table.length;<br>     Entry&lt;K, V&gt; current = table[index];<br>     <span class="hljs-comment">//遍历链表</span><br>    <span class="hljs-keyword">while</span> (current!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(current.k == k)<br>            <span class="hljs-keyword">return</span> current.v;<br>        current = current.next;<br>    &#125;<br>    <span class="hljs-comment">//不存在则返回空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-6实现remove方法"><a href="#3-6实现remove方法" class="headerlink" title="3.6实现remove方法"></a>3.6实现remove方法</h5><p>remove方法通过对应的键k删去在HashMap中对应的键值对Entry，同样是遍历链表，不同的是我们需要一个前置节点pre保存当前节点的上一个节点信息，这样才能正确地删除节点。删除成功则将size-1。</p><p>如果不存在这样一个节点，返回空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> k.hashCode() % table.length;<br>    <span class="hljs-type">V</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    Entry&lt;K, V&gt; current = table[index];<br>    <span class="hljs-comment">//遍历链表</span><br>    Entry&lt;K, V&gt; pre = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">while</span>(current!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(current.k == k)&#123;<br>            result = current.v;<br>            size--;<br>            <span class="hljs-keyword">if</span> (pre!=<span class="hljs-literal">null</span>)&#123;<br>                pre.next = current.next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                table[index] = current.next;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-comment">//向下遍历</span><br>        pre = current;<br>        current = current.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-7实现size方法与isEmpty方法"><a href="#3-7实现size方法与isEmpty方法" class="headerlink" title="3.7实现size方法与isEmpty方法"></a>3.7实现size方法与isEmpty方法</h5><p>比较简单的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> size==<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-测试MyHashMap"><a href="#4-测试MyHashMap" class="headerlink" title="4.测试MyHashMap"></a>4.测试MyHashMap</h4><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">hashMap_test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        MyHashMap&lt;Integer, Integer&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHashMap</span>&lt;&gt;();<br>        hashMap.put(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>);<br>        hashMap.put(<span class="hljs-number">2</span>,<span class="hljs-number">202</span>);<br>        hashMap.put(<span class="hljs-number">3</span>,<span class="hljs-number">303</span>);<br>        hashMap.put(<span class="hljs-number">1</span>,<span class="hljs-number">111</span>);<br><br>        <span class="hljs-type">int</span>[] keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;hashMap size:&quot;</span>+hashMap.size());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; keys.length;i++)&#123;<br>            System.out.println(keys[i]+<span class="hljs-string">&quot;: &quot;</span>+hashMap.get(keys[i]));<br>        &#125;<br><br>        hashMap.remove(<span class="hljs-number">1</span>);<br>        hashMap.remove(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;hashMap size:&quot;</span>+hashMap.size());<br>        System.out.println(<span class="hljs-number">1</span>+<span class="hljs-string">&quot;: &quot;</span>+hashMap.get(<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-number">3</span>+<span class="hljs-string">&quot;: &quot;</span>+hashMap.get(<span class="hljs-number">3</span>));<br>        System.out.println(<span class="hljs-number">2</span>+<span class="hljs-string">&quot;: &quot;</span>+hashMap.get(<span class="hljs-number">2</span>));  <span class="hljs-comment">//当然这里其实应该报错的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>本文简单地实现了一个HashMap，实现了Java中HashMap的put、get、remove、size、isEmpty等方法。但其实还有一些工作可以做，比如对HashMap进行扩容，当HashMap中元素过多的时候，我们需要将HashMap扩容以提高其查找速率，其实也就是减少HashMap中链表的数目，还有就是对于空值null的支持，其实HashMap是允许key为null的，当然，这一点不算太难。</p><p>对于我自己来说，原本我以为实现HashMap会是一件很困难的事情，所以我迟迟没有自己动手写一个，但是写了以后发现也就是这样，所以我们大家一定要多动手实践，也不要害怕困难，很多时候，其实是我们自己吓住了自己，导致没有去完成本可以完成的事情。</p><p>关于文章开头的那个问题：<strong>为什么当链表中的元素超过8个的时候需要将链表转换成红黑树？</strong></p><p>答案如下：</p><blockquote><p>在链表中查找时，根据next引用依次比较各个节点的key，长度为n的链表节点平均比较次数为n&#x2F;2</p><p>在红黑树中查找时，由于红黑树的特性，节点数为n的红黑树平均比较次数为log(n)</p></blockquote><p>链表长度超过8时树化（TREEIFY），正是因为n&#x3D;8，就是log(n) &lt; n&#x2F;2的阈值。而n&lt;6时，log(n) &gt; n&#x2F;2，红黑树解除树化（UNTREEIFY）。</p><p>如果文章内容存在不当之处，请各位读者能不吝赐教，笔者欢迎至极。</p><br><br><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://www.cnblogs.com/2511zzZ/p/12770864.html">手写一个简单的HashMap - 周周zzz - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/chenfei-java/p/10674341.html">纯手写实现HashMap - Java丨Mr.Chen - 博客园 (cnblogs.com)</a></p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap(JDK1.8)%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90?id=hashmap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">JavaGuide (gitee.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>源码剖析和实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>HashMap</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Builder设计模式</title>
    <link href="/2021/09/11/%E5%88%9D%E8%AF%86Builder%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/11/%E5%88%9D%E8%AF%86Builder%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>现在，假设我们正在一个为银行制作软件。在开始其他事情之前，我们需要用一种方式表示一个银行账户。我们第一版设计可能是下面这个样子：</p><pre><code class="hljs">public class BankAccount &#123;    private long accountNumber;    private String owner;    private double balance;    public BankAccount(long accountNumber, String owner, double balance) &#123;        this.accountNumber = accountNumber;        this.owner = owner;        this.balance = balance;    &#125;    //getter方法和setter方法&#125;</code></pre><p>我们可以用下面的方式来声明一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BankAccount</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>(<span class="hljs-number">123L</span>, <span class="hljs-string">&quot;lj&quot;</span>, <span class="hljs-number">100.00</span>);<br></code></pre></td></tr></table></figure><p>不幸的是，这样的设计是非常简单的。一个新的需求被送了过来，告诉你说我们需要记录每个账户每月的利率（interestRate），并且，还需要知道是在哪个分行（branch）。这听起来很容易，所以我们很容易就能提交我们第二个版本的BankAccount类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> accountNumber;<br>    <span class="hljs-keyword">private</span> String owner;<br>    <span class="hljs-keyword">private</span> String branch;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> balance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> interestRate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BankAccount</span><span class="hljs-params">(<span class="hljs-type">long</span> accountNumber, String owner, String branch, <span class="hljs-type">double</span> balance, <span class="hljs-type">double</span> interestRate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.accountNumber = accountNumber;<br>        <span class="hljs-built_in">this</span>.owner = owner;<br>        <span class="hljs-built_in">this</span>.branch = branch;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>        <span class="hljs-built_in">this</span>.interestRate = interestRate;<br>   &#125;<br><br>    <span class="hljs-comment">//getter方法和setter方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们及时更新银行账户，这使得我们获得了几个新用户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BankAccount</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>(<span class="hljs-number">456L</span>, <span class="hljs-string">&quot;lj&quot;</span>, <span class="hljs-string">&quot;Springfield&quot;</span>, <span class="hljs-number">100.00</span>, <span class="hljs-number">2.5</span>);<br><span class="hljs-type">BankAccount</span> <span class="hljs-variable">anotherAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>(<span class="hljs-number">789L</span>, <span class="hljs-string">&quot;wtx&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">100.00</span>);  <span class="hljs-comment">//这里的利息异常</span><br></code></pre></td></tr></table></figure><p>对以上这段代码，我们的编译器不会检查出错误。但是，我们知道利息肯定不可能是100%（如果有这样一个银行，那绝对已经倒闭了！）但是为什么会出现这种情况呢？提示：注意构造器的变量顺序。</p><p>如果我们有多个连续同类型的参数，我们很容易将他们弄混。而且编译器是不会把这个错误识别出来的，这可能会在我们运行时造成一些很难调试的问题。另外，在构造器上增加过多的参数将会使可读性变得很差。如果有一个构造器有10个不同的参数，那么你很难一眼看出这些参数分别代表着什么。更糟糕的是，有一些参数还是可选的，也就是说我们有一系列重载的构造器来面临可能存在的组合情况，否则我们就只能将<code>null</code>传递给构造器，但这不是一个好习惯。</p><p>为了解决这个问题，你可能会认为这个时候我们需要调用一个无参构造器然后使用setter填充变量信息。但是这又留下了一个新的问题。如果一个程序员忘记调用特定的<code>setter</code>方法了呢？结果这会使得这个对象部分初始化并且编译器还是不会发现任何问题。</p><p>因此，我们有两件事需要解决：</p><ul><li>避免过多的构造器参数</li><li>避免错误的对象状态</li></ul><p>这就是Builder设计模式最初所解决的问题。</p><h3 id="Builder设计模式"><a href="#Builder设计模式" class="headerlink" title="Builder设计模式"></a>Builder设计模式</h3><p>Builder设计模式允许我们在初始化一个对象的时候写出可读性好和容易理解的代码。</p><p>建造者<code>builder</code>通常拥有<code>BankAccount</code>的所有字段。我们将会在builder中配置所有我们想要的字段，并且我们会使用builder来创建一个<code>account</code>。同时，我们将会移除<code>BankAccount</code>中的所有<code>public</code>的构造器，只留下一个<code>private</code>的构造器以便于只有builder能够创建一个<code>account</code>对象。</p><p>在之前的<code>BankAccount</code>例子中，我们使用建造者模式后，这个类将会是下面这个样子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> accountNumber; <span class="hljs-comment">//这个字段很重要，所以我们会将其传给构造器</span><br>        <span class="hljs-keyword">private</span> String owner;<br>        <span class="hljs-keyword">private</span> String branch;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> balance;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> interestRate;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-type">long</span> accountNumber)</span> &#123;<br>            <span class="hljs-built_in">this</span>.accountNumber = accountNumber;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">withOwner</span><span class="hljs-params">(String owner)</span>&#123;<br>            <span class="hljs-built_in">this</span>.owner = owner;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <span class="hljs-comment">//通过返回一个Builder，可以创建一个流畅接口</span><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">atBranch</span><span class="hljs-params">(String branch)</span>&#123;<br>            <span class="hljs-built_in">this</span>.branch = branch;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">openingBalance</span><span class="hljs-params">(<span class="hljs-type">double</span> balance)</span>&#123;<br>            <span class="hljs-built_in">this</span>.balance = balance;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">atRate</span><span class="hljs-params">(<span class="hljs-type">double</span> interestRate)</span>&#123;<br>            <span class="hljs-built_in">this</span>.interestRate = interestRate;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> BankAccount <span class="hljs-title function_">build</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-comment">//在这里我们创建一个BankAccount的对象，并且这个对象将被充分的初始化</span><br>            <span class="hljs-type">BankAccount</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>();  <span class="hljs-comment">//因为builder是BankAccount的内部类, 我们可以调用BankAccount的私有构造器。</span><br>            account.accountNumber = <span class="hljs-built_in">this</span>.accountNumber;<br>            account.owner = <span class="hljs-built_in">this</span>.owner;<br>            account.branch = <span class="hljs-built_in">this</span>.branch;<br>            account.balance = <span class="hljs-built_in">this</span>.balance;<br>            account.interestRate = <span class="hljs-built_in">this</span>.interestRate;<br><br>            <span class="hljs-keyword">return</span> account;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//定义一个私有构造器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">BankAccount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//Constructor is now private.</span><br>    &#125;<br><br>    <span class="hljs-comment">//getter方法和setter方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们用使用建造者模式的<code>BankAccount</code>创建<code>account</code>对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BankAccount</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>.Builder(<span class="hljs-number">1234L</span>)<br>            .withOwner(<span class="hljs-string">&quot;lj&quot;</span>)<br>            .atBranch(<span class="hljs-string">&quot;Springfield&quot;</span>)<br>            .openingBalance(<span class="hljs-number">100</span>)<br>            .atRate(<span class="hljs-number">2.5</span>)<br>            .build();<br><br><span class="hljs-type">BankAccount</span> <span class="hljs-variable">anotherAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>.Builder(<span class="hljs-number">4567L</span>)<br>            .withOwner(<span class="hljs-string">&quot;wtx&quot;</span>)<br>            .atBranch(<span class="hljs-string">&quot;Springfield&quot;</span>)<br>            .openingBalance(<span class="hljs-number">100</span>)<br>            .atRate(<span class="hljs-number">2.5</span>)<br>            .build();<br></code></pre></td></tr></table></figure><p>虽然上面的代码看上去更长了，但是却更清晰了，更容易理解了。对于读代码时间多于写代码时间的我们来说，这显然是一种更棒的形式。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在一个简单的银行账户的例子从简单到变复杂的过程中，我们使用了建造者模式探讨了我们发现的问题。</p><p>如果你发现你正处于在一个构造器上添加新的参数来解决问题而导致代码变得很难读的情况，那么对你来说这可能是你自己亲手实践，使用建造者模式重构你的代码的大好时机。</p><p>在笔者阅读这篇文章的时候，正在阅读一个使用Builder设计模式的项目代码，不得不说，使用Builder设计模式的代码虽然看上去长，有点使人畏惧，但是当你开始看上几眼之后，你会发现对你来说，读懂那文字，你就知道这个方法是干什么的了，这个类的构造也是十分清晰，基本是一目了然。经常也看到这样的言论：<strong>伟大的代码是连初学者也能看懂的代码</strong>。接触到builder设计模式以后，深以为然。</p><p>本文取自Dzone:<a href="https://dzone.com/articles/design-patterns-the-builder-pattern">Design Patterns: The Builder Pattern</a></p>]]></content>
    
    
    <categories>
      
      <category>架构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
